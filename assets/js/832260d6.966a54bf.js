"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[728],{5680:(e,a,n)=>{n.d(a,{xA:()=>p,yg:()=>d});var t=n(6540);function s(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function m(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){s(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,s=function(e,a){if(null==e)return{};var n,t,s={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(s[n]=e[n]);return s}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r=t.createContext({}),l=function(e){var a=t.useContext(r),n=a;return e&&(n="function"==typeof e?e(a):m(m({},a),e)),n},p=function(e){var a=l(e.components);return t.createElement(r.Provider,{value:a},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},y=t.forwardRef((function(e,a){var n=e.components,s=e.mdxType,i=e.originalType,r=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=l(n),y=s,d=c["".concat(r,".").concat(y)]||c[y]||g[y]||i;return n?t.createElement(d,m(m({ref:a},p),{},{components:n})):t.createElement(d,m({ref:a},p))}));function d(e,a){var n=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var i=n.length,m=new Array(i);m[0]=y;var o={};for(var r in a)hasOwnProperty.call(a,r)&&(o[r]=a[r]);o.originalType=e,o[c]="string"==typeof e?e:s,m[1]=o;for(var l=2;l<i;l++)m[l]=n[l];return t.createElement.apply(null,m)}return t.createElement.apply(null,n)}y.displayName="MDXCreateElement"},3717:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>r,contentTitle:()=>m,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var t=n(8168),s=(n(6540),n(5680));n(1873);const i={},m="Polynomial API Overview",o={unversionedId:"icicle/polynomials/overview",id:"icicle/polynomials/overview",title:"Polynomial API Overview",description:"Introduction",source:"@site/docs/icicle/polynomials/overview.md",sourceDirName:"icicle/polynomials",slug:"/icicle/polynomials/overview",permalink:"/icicle/polynomials/overview",editUrl:"https://github.com/ingonyama-zk/icicle/tree/main/docs/icicle/polynomials/overview.md",tags:[],version:"current",lastUpdatedBy:"VitaliiH",lastUpdatedAt:1715232285,formattedLastUpdatedAt:"5/9/2024",frontMatter:{},sidebar:"GettingStartedSidebar",previous:{title:"Poseidon",permalink:"/icicle/primitives/poseidon"},next:{title:"Multi GPU with ICICLE",permalink:"/icicle/multi-gpu"}},r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Backend Agnostic Architecture",id:"backend-agnostic-architecture",level:3},{value:"Templating in the Polynomial API",id:"templating-in-the-polynomial-api",level:3},{value:"Default instantiation",id:"default-instantiation",level:4},{value:"Extended use cases",id:"extended-use-cases",level:4},{value:"Supported Operations",id:"supported-operations",level:3},{value:"Usage",id:"usage",level:2},{value:"Backend Initialization",id:"backend-initialization",level:3},{value:"Construction",id:"construction",level:3},{value:"Arithmetic",id:"arithmetic",level:3},{value:"Example",id:"example",level:4},{value:"Evaluation",id:"evaluation",level:3},{value:"Manipulations",id:"manipulations",level:3},{value:"Monomials",id:"monomials",level:4},{value:"Computing the degree of a Polynomial",id:"computing-the-degree-of-a-polynomial",level:4},{value:"Slicing",id:"slicing",level:4},{value:"Memory access (copy/view)",id:"memory-access-copyview",level:3},{value:"Copying",id:"copying",level:4},{value:"Views",id:"views",level:4},{value:"What is a Memory View?",id:"what-is-a-memory-view",level:5},{value:"Applications of Memory Views",id:"applications-of-memory-views",level:5},{value:"Obtaining and Using Views",id:"obtaining-and-using-views",level:5},{value:"Integrity-Pointer: Managing Memory Views",id:"integrity-pointer-managing-memory-views",level:5},{value:"Evaluations View: Accessing Polynomial Evaluations Efficiently",id:"evaluations-view-accessing-polynomial-evaluations-efficiently",level:4},{value:"Multi-GPU Support with CUDA Backend",id:"multi-gpu-support-with-cuda-backend",level:2},{value:"Setting the CUDA Device",id:"setting-the-cuda-device",level:3},{value:"Allocation Consistency",id:"allocation-consistency",level:3},{value:"Matching Devices for Operations",id:"matching-devices-for-operations",level:3},{value:"Device-Agnostic Operations",id:"device-agnostic-operations",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Best Practices",id:"best-practices",level:3}],p={toc:l},c="wrapper";function g(e){let{components:a,...n}=e;return(0,s.yg)(c,(0,t.A)({},p,n,{components:a,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"polynomial-api-overview"},"Polynomial API Overview"),(0,s.yg)("h2",{id:"introduction"},"Introduction"),(0,s.yg)("p",null,"The Polynomial API offers a robust framework for polynomial operations within a computational environment. It's designed for flexibility and efficiency, supporting a broad range of operations like arithmetic, evaluation, and manipulation, all while abstracting from the computation and storage specifics. This enables adaptability to various backend technologies, employing modern C++ practices."),(0,s.yg)("h2",{id:"key-features"},"Key Features"),(0,s.yg)("h3",{id:"backend-agnostic-architecture"},"Backend Agnostic Architecture"),(0,s.yg)("p",null,"Our API is structured to be independent of any specific computational backend. While a CUDA backend is currently implemented, the architecture facilitates easy integration of additional backends. This capability allows users to perform polynomial operations without the need to tailor their code to specific hardware, enhancing code portability and scalability."),(0,s.yg)("h3",{id:"templating-in-the-polynomial-api"},"Templating in the Polynomial API"),(0,s.yg)("p",null,"The Polynomial API is designed with a templated structure to accommodate different data types for coefficients, the domain, and images. This flexibility allows the API to be adapted for various computational needs and types of data."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"template <typename Coeff, typename Domain = Coeff, typename Image = Coeff>\nclass Polynomial {\n    // Polynomial class definition\n}\n")),(0,s.yg)("p",null,"In this template:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"Coeff")),": Represents the type of the coefficients of the polynomial."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"Domain")),": Specifies the type for the input values over which the polynomial is evaluated. By default, it is the same as the type of the coefficients but can be specified separately to accommodate different computational contexts."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"strong"},"Image")),": Defines the type of the output values of the polynomial. This is typically the same as the coefficients.")),(0,s.yg)("h4",{id:"default-instantiation"},"Default instantiation"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"extern template class Polynomial<scalar_t>;\n")),(0,s.yg)("h4",{id:"extended-use-cases"},"Extended use cases"),(0,s.yg)("p",null,"The templated nature of the Polynomial API also supports more complex scenarios. For example, coefficients and images could be points on an elliptic curve (EC points), which are useful in cryptographic applications and advanced algebraic structures. This approach allows the API to be extended easily to support new algebraic constructions without modifying the core implementation."),(0,s.yg)("h3",{id:"supported-operations"},"Supported Operations"),(0,s.yg)("p",null,"The Polynomial class encapsulates a polynomial, providing a variety of operations:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Construction"),": Create polynomials from coefficients or evaluations on roots-of-unity domains."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Arithmetic Operations"),": Perform addition, subtraction, multiplication, and division."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Evaluation"),": Directly evaluate polynomials at specific points or across a domain."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Manipulation"),": Features like slicing polynomials, adding or subtracting monomials inplace, and computing polynomial degrees."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Memory Access"),": Access internal states or obtain device-memory views of polynomials.")),(0,s.yg)("h2",{id:"usage"},"Usage"),(0,s.yg)("p",null,"This section outlines how to use the Polynomial API in C++. Bindings for Rust and Go are detailed under the Bindings sections."),(0,s.yg)("h3",{id:"backend-initialization"},"Backend Initialization"),(0,s.yg)("p",null,"Initialization with an appropriate factory is required to configure the computational context and backend."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},'#include "polynomials/polynomials.h"\n#include "polynomials/cuda_backend/polynomial_cuda_backend.cuh"\n\n// Initialize with a CUDA backend\nPolynomial::initialize(std::make_shared<CUDAPolynomialFactory>());\n')),(0,s.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.yg)("div",{parentName:"div",className:"admonition-heading"},(0,s.yg)("h5",{parentName:"div"},(0,s.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,s.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.yg)("div",{parentName:"div",className:"admonition-content"},(0,s.yg)("p",{parentName:"div"},"Initialization of a factory must be done per linked curve or field."))),(0,s.yg)("h3",{id:"construction"},"Construction"),(0,s.yg)("p",null,"Polynomials can be constructed from coefficients, from evaluations on roots-of-unity domains, or by cloning existing polynomials."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Construction\nstatic Polynomial from_coefficients(const Coeff* coefficients, uint64_t nof_coefficients);\nstatic Polynomial from_rou_evaluations(const Image* evaluations, uint64_t nof_evaluations);\n// Clone the polynomial\nPolynomial clone() const;\n")),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto p_from_coeffs = Polynomial_t::from_coefficients(coeff /* :scalar_t* */, nof_coeffs);\nauto p_from_rou_evals = Polynomial_t::from_rou_evaluations(rou_evals /* :scalar_t* */, nof_evals);\nauto p_cloned = p.clone(); // p_cloned and p do not share memory\n")),(0,s.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.yg)("div",{parentName:"div",className:"admonition-heading"},(0,s.yg)("h5",{parentName:"div"},(0,s.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,s.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.yg)("div",{parentName:"div",className:"admonition-content"},(0,s.yg)("p",{parentName:"div"},"The coefficients or evaluations may be allocated either on host or device memory. In both cases the memory is copied to the backend device."))),(0,s.yg)("h3",{id:"arithmetic"},"Arithmetic"),(0,s.yg)("p",null,"Constructed polynomials can be used for various arithmetic operations:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Addition\nPolynomial operator+(const Polynomial& rhs) const; \nPolynomial& operator+=(const Polynomial& rhs); // inplace addition\n\n// Subtraction\nPolynomial operator-(const Polynomial& rhs) const;\n\n// Multiplication\nPolynomial operator*(const Polynomial& rhs) const;\nPolynomial operator*(const Domain& scalar) const; // scalar multiplication\n\n// Division A(x) = B(x)Q(x) + R(x)\nstd::pair<Polynomial, Polynomial> divide(const Polynomial& rhs) const; // returns (Q(x), R(x))\nPolynomial operator/(const Polynomial& rhs) const; // returns quotient Q(x)\nPolynomial operator%(const Polynomial& rhs) const; // returns remainder R(x)\nPolynomial divide_by_vanishing_polynomial(uint64_t degree) const; // sdivision by the vanishing polynomial V(x)=X^N-1\n")),(0,s.yg)("h4",{id:"example"},"Example"),(0,s.yg)("p",null,"Given polynomials A(x),B(x),C(x) and V(x) the vanishing polynomial."),(0,s.yg)("div",{className:"math math-display"},(0,s.yg)("span",{parentName:"div",className:"katex-display"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"H"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"="),(0,s.yg)("mfrac",{parentName:"mrow"},(0,s.yg)("mrow",{parentName:"mfrac"},(0,s.yg)("mi",{parentName:"mrow"},"A"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"\u22c5"),(0,s.yg)("mi",{parentName:"mrow"},"B"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"\u2212"),(0,s.yg)("mi",{parentName:"mrow"},"C"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.yg)("mrow",{parentName:"mfrac"},(0,s.yg)("mi",{parentName:"mrow"},"V"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"))),(0,s.yg)("mtext",{parentName:"mrow"},"\xa0"),(0,s.yg)("mi",{parentName:"mrow"},"w"),(0,s.yg)("mi",{parentName:"mrow"},"h"),(0,s.yg)("mi",{parentName:"mrow"},"e"),(0,s.yg)("mi",{parentName:"mrow"},"r"),(0,s.yg)("mi",{parentName:"mrow"},"e"),(0,s.yg)("mtext",{parentName:"mrow"},"\xa0"),(0,s.yg)("mi",{parentName:"mrow"},"V"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"="),(0,s.yg)("msup",{parentName:"mrow"},(0,s.yg)("mi",{parentName:"msup"},"X"),(0,s.yg)("mi",{parentName:"msup"},"N")),(0,s.yg)("mo",{parentName:"mrow"},"\u2212"),(0,s.yg)("mn",{parentName:"mrow"},"1")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"H(x)=\\frac{A(x) \\cdot B(x) - C(x)}{V(x)} \\space where \\space V(x) = X^{N}-1")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.08125em"}},"H"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.yg)("span",{parentName:"span",className:"mrel"},"="),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"2.363em",verticalAlign:"-0.936em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,s.yg)("span",{parentName:"span",className:"mfrac"},(0,s.yg)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"1.427em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-2.314em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"))),(0,s.yg)("span",{parentName:"span",style:{top:"-3.23em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.yg)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,s.yg)("span",{parentName:"span",style:{top:"-3.677em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"A"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mbin"},"\u22c5"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05017em"}},"B"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07153em"}},"C"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")")))),(0,s.yg)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.936em"}},(0,s.yg)("span",{parentName:"span"}))))),(0,s.yg)("span",{parentName:"span",className:"mclose nulldelimiter"})),(0,s.yg)("span",{parentName:"span",className:"mspace"},"\xa0"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02691em"}},"w"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"ere"),(0,s.yg)("span",{parentName:"span",className:"mspace"},"\xa0"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.22222em"}},"V"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.yg)("span",{parentName:"span",className:"mrel"},"="),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.9747em",verticalAlign:"-0.0833em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.07847em"}},"X"),(0,s.yg)("span",{parentName:"span",className:"msupsub"},(0,s.yg)("span",{parentName:"span",className:"vlist-t"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8913em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-3.113em",marginRight:"0.05em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal mtight",style:{marginRight:"0.10903em"}},"N"))))))))),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},"1")))))),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto H = (A*B-C).divide_by_vanishing_polynomial(N);\n")),(0,s.yg)("h3",{id:"evaluation"},"Evaluation"),(0,s.yg)("p",null,"Evaluate polynomials at arbitrary domain points or across a domain."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"Image operator()(const Domain& x) const; // evaluate f(x)\nvoid evaluate(const Domain* x, Image* evals /*OUT*/) const;\nvoid evaluate_on_domain(Domain* domain, uint64_t size, Image* evals /*OUT*/) const; // caller allocates memory\n")),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"Coeff x = rand();\nImage f_x = f(x); // evaluate f at x\n\n// evaluate f(x) on a domain\nuint64_t domain_size = ...;\nauto domain = /*build domain*/; // host or device memory\nauto evaluations = std::make_unique<scalar_t[]>(domain_size); // can be device memory too\nf.evaluate_on_domain(domain, domain_size, evaluations);\n")),(0,s.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.yg)("div",{parentName:"div",className:"admonition-heading"},(0,s.yg)("h5",{parentName:"div"},(0,s.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,s.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.yg)("div",{parentName:"div",className:"admonition-content"},(0,s.yg)("p",{parentName:"div"},"For special domains such as roots of unity, this method is not the most efficient for two reasons:"),(0,s.yg)("ul",{parentName:"div"},(0,s.yg)("li",{parentName:"ul"},"Need to build the domain of size N."),(0,s.yg)("li",{parentName:"ul"},"The implementation is not trying to identify this special domain.")),(0,s.yg)("p",{parentName:"div"},"Therefore the computation is typically ",(0,s.yg)("span",{parentName:"p",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"O"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("msup",{parentName:"mrow"},(0,s.yg)("mi",{parentName:"msup"},"n"),(0,s.yg)("mn",{parentName:"msup"},"2")),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n^2)")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1.0641em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.yg)("span",{parentName:"span",className:"msupsub"},(0,s.yg)("span",{parentName:"span",className:"vlist-t"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,s.yg)("span",{parentName:"span",className:"mclose"},")")))))," rather than ",(0,s.yg)("span",{parentName:"p",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"O"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"n"),(0,s.yg)("mi",{parentName:"mrow"},"l"),(0,s.yg)("mi",{parentName:"mrow"},"o"),(0,s.yg)("mi",{parentName:"mrow"},"g"),(0,s.yg)("mi",{parentName:"mrow"},"n"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(nlogn)")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"))))),".\nSee the 'device views' section for more details."))),(0,s.yg)("h3",{id:"manipulations"},"Manipulations"),(0,s.yg)("p",null,"Beyond arithmetic, the API supports efficient polynomial manipulations:"),(0,s.yg)("h4",{id:"monomials"},"Monomials"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Monomial operations\nPolynomial& add_monomial_inplace(Coeff monomial_coeff, uint64_t monomial = 0);\nPolynomial& sub_monomial_inplace(Coeff monomial_coeff, uint64_t monomial = 0);\n")),(0,s.yg)("p",null,"The ability to add or subtract monomials directly and in-place is an efficient way to manipualte polynomials."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"f.add_monomial_in_place(scalar_t::from(5)); // f(x) += 5\nf.sub_monomial_in_place(scalar_t::from(3), 8); // f(x) -= 3x^8\n")),(0,s.yg)("h4",{id:"computing-the-degree-of-a-polynomial"},"Computing the degree of a Polynomial"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Degree computation\nint64_t degree();\n")),(0,s.yg)("p",null,"The degree of a polynomial is a fundamental characteristic that describes the highest power of the variable in the polynomial expression with a non-zero coefficient.\nThe ",(0,s.yg)("inlineCode",{parentName:"p"},"degree()")," function in the API returns the degree of the polynomial, corresponding to the highest exponent with a non-zero coefficient."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"For the polynomial ",(0,s.yg)("span",{parentName:"li",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"f"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"="),(0,s.yg)("msup",{parentName:"mrow"},(0,s.yg)("mi",{parentName:"msup"},"x"),(0,s.yg)("mn",{parentName:"msup"},"5")),(0,s.yg)("mo",{parentName:"mrow"},"+"),(0,s.yg)("mn",{parentName:"mrow"},"2"),(0,s.yg)("msup",{parentName:"mrow"},(0,s.yg)("mi",{parentName:"msup"},"x"),(0,s.yg)("mn",{parentName:"msup"},"3")),(0,s.yg)("mo",{parentName:"mrow"},"+"),(0,s.yg)("mn",{parentName:"mrow"},"4")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(x) = x^5 + 2x^3 + 4")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.yg)("span",{parentName:"span",className:"mrel"},"="),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"msupsub"},(0,s.yg)("span",{parentName:"span",className:"vlist-t"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mtight"},"5")))))))),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mbin"},"+"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.8974em",verticalAlign:"-0.0833em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},"2"),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"msupsub"},(0,s.yg)("span",{parentName:"span",className:"vlist-t"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mtight"},"3")))))))),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.yg)("span",{parentName:"span",className:"mbin"},"+"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},"4"))))),", the degree is 5 because the highest power of ",(0,s.yg)("span",{parentName:"li",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"x")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x")))))," with a non-zero coefficient is 5."),(0,s.yg)("li",{parentName:"ul"},"For a scalar value such as a constant term (e.g., ",(0,s.yg)("span",{parentName:"li",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"f"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"="),(0,s.yg)("mn",{parentName:"mrow"},"7")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(x) = 7")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.yg)("span",{parentName:"span",className:"mrel"},"="),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},"7"))))),", the degree is considered 0, as it corresponds to ",(0,s.yg)("span",{parentName:"li",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("msup",{parentName:"mrow"},(0,s.yg)("mi",{parentName:"msup"},"x"),(0,s.yg)("mn",{parentName:"msup"},"0"))),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"x^0")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.8141em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"msupsub"},(0,s.yg)("span",{parentName:"span",className:"vlist-t"},(0,s.yg)("span",{parentName:"span",className:"vlist-r"},(0,s.yg)("span",{parentName:"span",className:"vlist",style:{height:"0.8141em"}},(0,s.yg)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,s.yg)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,s.yg)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,s.yg)("span",{parentName:"span",className:"mord mtight"},"0")))))))))))),"."),(0,s.yg)("li",{parentName:"ul"},"The degree of the zero polynomial, ",(0,s.yg)("span",{parentName:"li",className:"math math-inline"},(0,s.yg)("span",{parentName:"span",className:"katex"},(0,s.yg)("span",{parentName:"span",className:"katex-mathml"},(0,s.yg)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.yg)("semantics",{parentName:"math"},(0,s.yg)("mrow",{parentName:"semantics"},(0,s.yg)("mi",{parentName:"mrow"},"f"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.yg)("mi",{parentName:"mrow"},"x"),(0,s.yg)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,s.yg)("mo",{parentName:"mrow"},"="),(0,s.yg)("mn",{parentName:"mrow"},"0")),(0,s.yg)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"f(x) = 0")))),(0,s.yg)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10764em"}},"f"),(0,s.yg)("span",{parentName:"span",className:"mopen"},"("),(0,s.yg)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,s.yg)("span",{parentName:"span",className:"mclose"},")"),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.yg)("span",{parentName:"span",className:"mrel"},"="),(0,s.yg)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.yg)("span",{parentName:"span",className:"base"},(0,s.yg)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.yg)("span",{parentName:"span",className:"mord"},"0"))))),', where there are no non-zero coefficients, is defined as -1. This special case often represents an "empty" or undefined state in many mathematical contexts.')),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto f = /*some expression*/;\nauto degree_of_f = f.degree();\n")),(0,s.yg)("h4",{id:"slicing"},"Slicing"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Slicing and selecting even or odd components.\nPolynomial slice(uint64_t offset, uint64_t stride, uint64_t size = 0 /*0 means take all elements*/);\nPolynomial even();\nPolynomial odd();\n")),(0,s.yg)("p",null,"The Polynomial API provides methods for slicing polynomials and selecting specific components, such as even or odd indexed terms. Slicing allows extracting specific sections of a polynomial based on an offset, stride, and size."),(0,s.yg)("p",null,"The following examples demonstrate folding a polynomial's even and odd parts and arbitrary slicing;"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// folding a polynomials even and odd parts with randomness\nauto x = rand();\nauto even = f.even();\nauto odd = f.odd();\nauto fold_poly = even + odd * x;\n\n// arbitrary slicing (first quarter)\nauto first_quarter = f.slice(0 /*offset*/, 1 /*stride*/, f.degree()/4 /*size*/);\n")),(0,s.yg)("h3",{id:"memory-access-copyview"},"Memory access (copy/view)"),(0,s.yg)("p",null,"Access to the polynomial's internal state can be vital for operations like commitment schemes or when more efficient custom operations are necessary. This can be done either by copying or viewing the polynomial"),(0,s.yg)("h4",{id:"copying"},"Copying"),(0,s.yg)("p",null,"Copies the polynomial coefficients to either host or device allocated memory."),(0,s.yg)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.yg)("div",{parentName:"div",className:"admonition-heading"},(0,s.yg)("h5",{parentName:"div"},(0,s.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,s.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.yg)("div",{parentName:"div",className:"admonition-content"},(0,s.yg)("p",{parentName:"div"},"Copying to host memory is backend agnostic while copying to device memory requires the memory to be allocated on the corresponding backend."))),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"Coeff get_coeff(uint64_t idx) const; // copy single coefficient to host\nuint64_t copy_coeffs(Coeff* coeffs, uint64_t start_idx, uint64_t end_idx) const;\n")),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto coeffs_device = /*allocate CUDA or host memory*/\nf.copy_coeffs(coeffs_device, 0/*start*/, f.degree());\n  \nMSMConfig cfg = msm::defaultMSMConfig();\ncfg.are_points_on_device = true; // assuming copy to device memory\nauto rv = msm::MSM(coeffs_device, points, msm_size, cfg, results);\n")),(0,s.yg)("h4",{id:"views"},"Views"),(0,s.yg)("p",null,"The Polynomial API supports efficient data handling through the use of memory views. These views provide direct access to the polynomial's internal state, such as coefficients or evaluations without the need to copy data. This feature is particularly useful for operations that require direct access to device memory, enhancing both performance and memory efficiency."),(0,s.yg)("h5",{id:"what-is-a-memory-view"},"What is a Memory View?"),(0,s.yg)("p",null,"A memory view is essentially a pointer to data stored in device memory. By providing a direct access pathway to the data, it eliminates the need for data duplication, thus conserving both time and system resources. This is especially beneficial in high-performance computing environments where data size and operation speed are critical factors."),(0,s.yg)("h5",{id:"applications-of-memory-views"},"Applications of Memory Views"),(0,s.yg)("p",null,"Memory views are extremely versatile and can be employed in various computational contexts such as:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"Commitments"),": Views can be used to commit polynomial states in cryptographic schemes, such as Multi-Scalar Multiplications (MSM), or for constructing Merkle trees without duplicating the underlying data."),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("strong",{parentName:"li"},"External Computations"),": They allow external functions or algorithms to utilize the polynomial's data directly, facilitating operations outside the core polynomial API. This is useful for custom operations that are not covered by the API.")),(0,s.yg)("h5",{id:"obtaining-and-using-views"},"Obtaining and Using Views"),(0,s.yg)("p",null,"To create and use views within the Polynomial API, functions are provided to obtain pointers to both coefficients and evaluation data. Here\u2019s how they are generally structured:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Obtain a view of the polynomial's coefficients\nstd::tuple<IntegrityPointer<Coeff>, uint64_t /*size*/, uint64_t /*device_id*/> get_coefficients_view();\n// obtain a view of the evaluations. Can specify the domain size and whether to compute reversed evaluations.\nstd::tuple<IntegrityPointer<Image>, uint64_t /*size*/, uint64_t /*device_id*/>\nget_rou_evaluations_view(uint64_t nof_evaluations = 0, bool is_reversed = false);\n")),(0,s.yg)("p",null,"Example usage:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto [coeffs_view, size, device_id] = polynomial.get_coefficients_view();\n\n// Use coeffs_view in a computational routine that requires direct access to polynomial coefficients\n// Example: Passing the view to a GPU-accelerated function\ngpu_accelerated_function(coeffs_view.get(),...);\n")),(0,s.yg)("h5",{id:"integrity-pointer-managing-memory-views"},"Integrity-Pointer: Managing Memory Views"),(0,s.yg)("p",null,"Within the Polynomial API, memory views are managed through a specialized tool called the Integrity-Pointer. This pointer type is designed to safeguard operations by monitoring the validity of the memory it points to. It can detect if the memory has been modified or released, thereby preventing unsafe access to stale or non-existent data.\nThe Integrity-Pointer not only acts as a regular pointer but also provides additional functionality to ensure the integrity of the data it references. Here are its key features:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Checks whether the pointer is still considered valid\nbool isValid() const;\n\n// Retrieves the raw pointer or nullptr if pointer is invalid\nconst T* get() const;\n\n// Dereferences the pointer. Throws exception if the pointer is invalid.\nconst T& operator*() const;\n\n//Provides access to the member of the pointed-to object. Throws exception if the pointer is invalid.\nconst T* operator->() const;\n")),(0,s.yg)("p",null,"Consider the Following case:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"auto [coeff_view, size, device] = f.get_coefficients_view();\n\n// Use the coefficients view to perform external operations\ncommit_to_polynomial(coeff_view.get(), size);\n\n// Modification of the original polynomial\nf += g; // Any operation that modifies 'f' potentially invalidates 'coeff_view'\n\n// Check if the view is still valid before using it further\nif (coeff_view.isValid()) {\n    perform_additional_computation(coeff_view.get(), size);\n} else {\n    handle_invalid_data();\n}\n")),(0,s.yg)("h4",{id:"evaluations-view-accessing-polynomial-evaluations-efficiently"},"Evaluations View: Accessing Polynomial Evaluations Efficiently"),(0,s.yg)("p",null,"The Polynomial API offers a specialized method, ",(0,s.yg)("inlineCode",{parentName:"p"},"get_rou_evaluations_view(...)"),", which facilitates direct access to the evaluations of a polynomial. This method is particularly useful for scenarios where polynomial evaluations need to be accessed frequently or manipulated externally without the overhead of copying data.\nThis method provides a memory view into the device memory where polynomial evaluations are stored. It allows for efficient interpolation on larger domains, leveraging the raw evaluations directly from memory."),(0,s.yg)("div",{className:"admonition admonition-warning alert alert--danger"},(0,s.yg)("div",{parentName:"div",className:"admonition-heading"},(0,s.yg)("h5",{parentName:"div"},(0,s.yg)("span",{parentName:"h5",className:"admonition-icon"},(0,s.yg)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.yg)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,s.yg)("div",{parentName:"div",className:"admonition-content"},(0,s.yg)("p",{parentName:"div"},"Invalid request: requesting evaluations on a domain smaller than the degree of the polynomial is not supported and is considered invalid."))),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Assume a polynomial `p` of degree N\nauto [evals_view, size, device_id] = p.get_rou_evaluations_view(4*N); // expanding the evaluation domain\n\n// Use the evaluations view to perform further computations or visualizations\nprocess_polynomial_evaluations(evals_view.get(), size, device_id);\n")),(0,s.yg)("h2",{id:"multi-gpu-support-with-cuda-backend"},"Multi-GPU Support with CUDA Backend"),(0,s.yg)("p",null,"The Polynomial API includes comprehensive support for multi-GPU environments, a crucial feature for leveraging the full computational power of systems equipped with multiple NVIDIA GPUs. This capability is part of the API's CUDA backend, which is designed to efficiently manage polynomial computations across different GPUs."),(0,s.yg)("h3",{id:"setting-the-cuda-device"},"Setting the CUDA Device"),(0,s.yg)("p",null,"Like other components of the icicle framework, the Polynomial API allows explicit setting of the current CUDA device:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"cudaSetDevice(int deviceID);\n")),(0,s.yg)("p",null,"This function sets the active CUDA device. All subsequent operations that allocate or deal with polynomial data will be performed on this device."),(0,s.yg)("h3",{id:"allocation-consistency"},"Allocation Consistency"),(0,s.yg)("p",null,"Polynomials are always allocated on the current CUDA device at the time of their creation. It is crucial to ensure that the device context is correctly set before initiating any operation that involves memory allocation:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Set the device before creating polynomials\ncudaSetDevice(0);\nPolynomial p1 = Polynomial::from_coefficients(coeffs, size);\n\ncudaSetDevice(1);\nPolynomial p2 = Polynomial::from_coefficients(coeffs, size);\n")),(0,s.yg)("h3",{id:"matching-devices-for-operations"},"Matching Devices for Operations"),(0,s.yg)("p",null,"When performing operations that result in the creation of new polynomials (such as addition or multiplication), it is imperative that both operands are on the same CUDA device. If the operands reside on different devices, an exception is thrown:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// Ensure both operands are on the same device\ncudaSetDevice(0);\nauto p3 = p1 + p2; // Throws an exception if p1 and p2 are not on the same device\n")),(0,s.yg)("h3",{id:"device-agnostic-operations"},"Device-Agnostic Operations"),(0,s.yg)("p",null,"Operations that do not involve the creation of new polynomials, such as computing the degree of a polynomial or performing in-place modifications, can be executed regardless of the current device setting:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-cpp"},"// 'degree' and in-place operations do not require device matching\nint deg = p1.degree();\np1 += p2; // Valid if p1 and p2 are on the same device, throws otherwise\n")),(0,s.yg)("h3",{id:"error-handling"},"Error Handling"),(0,s.yg)("p",null,"The API is designed to throw exceptions if operations are attempted across polynomials that are not located on the same GPU. This ensures that all polynomial operations are performed consistently and without data integrity issues due to device mismatches."),(0,s.yg)("h3",{id:"best-practices"},"Best Practices"),(0,s.yg)("p",null,"To maximize the performance and avoid runtime errors in a multi-GPU setup, always ensure that:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"The CUDA device is set correctly before polynomial allocation."),(0,s.yg)("li",{parentName:"ul"},"Operations involving new polynomial creation are performed with operands on the same device.")),(0,s.yg)("p",null,"By adhering to these guidelines, developers can effectively harness the power of multiple GPUs to handle large-scale polynomial computations efficiently."))}g.isMDXComponent=!0},1873:(e,a,n)=>{n(6540)}}]);